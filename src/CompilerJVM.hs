-- automatically generated by BNF Converter
module Main where


-- import System.IO ( stdin, hGetContents )
-- import System.Environment ( getArgs, getProgName )
import System.Environment ( getArgs, )
import System.Exit ( exitFailure, exitSuccess )

-- import LexInstant
import ParInstant
-- import SkelInstant
import PrintInstant
import AbsInstant

-- import qualified Data.Map as Map
import Data.List
import Control.Monad
import Control.Monad.Except


import ErrM

type Verbosity = Int

putStrV :: Verbosity -> String -> IO ()
putStrV v s = when (v > 1) $ putStrLn s

runFile :: Verbosity -> FilePath -> IO ()
runFile v f = putStrLn f >> readFile f >>= run v

run :: Verbosity -> String -> IO ()
run v s = let ts = myLexer s in case pProgram ts of
           Bad e    -> do putStrLn "\nParse              Failed...\n"
                          putStrV v "Tokens:"
                          putStrV v $ show ts
                          putStrLn e
                          exitFailure
           Ok  tree -> do putStrLn "\nParse Successful!"
                          showTree v tree
                          compile tree
                          exitSuccess

showTree :: (Show a, Print a) => Int -> a -> IO ()
showTree v tree
 = do
      putStrV v $ "\n[Abstract Syntax]\n\n" ++ show tree
      putStrV v $ "\n[Linearized tree]\n\n" ++ printTree tree

usage :: IO ()
usage = do
  putStrLn $ unlines
    [ "usage: Call with one of the following argument combinations:"
    , "  --help          Display this help message."
    , "  (files)         Parse content of files verbosely."
    , "  -s (files)      Silent mode. Parse content of files silently."
    ]
  exitFailure

main :: IO ()
main = do
  args <- getArgs
  case args of
    ["--help"] -> usage
    [] -> putStrLn "No file specified!" >> exitFailure
    "-s":fs -> mapM_ (runFile 0) fs
    fs -> mapM_ (runFile 2) fs

max3 :: Int -> Int -> Int ->Int
max3 a b c = max a $ max b c

-- type State = Map.Map String Integer
-- data Instruction = Expr String | Ass String String deriving (Eq, Show)
type Instruction = String

compile :: Program -> IO ()
compile program = mapM_ print (compileProgram program)

compileProgram :: Program -> Except String [[Instruction]] -- zmianić typ na listę
-- compileProgram (Prog stmts) = mapM compileStmt stmts
compileProgram (Prog stmts) = return [["ala"]]

-- compileStmt :: Stmt -> Except String [Instruction]
compileStmt :: Stmt -> Except String ([Instruction], Int)
-- compileStmt (SExp expr) = [Exp $ show expr]
-- compileStmt (SExp expr) = [show expr]
compileStmt (SExp expr) = compileExpr expr [""] -- TODO

-- compileStmt (SAss (Ident name) expr) = [Ass name (show expr)]
-- compileStmt (SAss (Ident name) expr) = [(show expr)]
compileStmt (SAss (Ident name) expr) = return ([name], 0)

-- compileExpr :: Exp -> Except String [Instruction]
compileExpr :: Exp -> [String] -> Except String ([Instruction], Int)
compileExpr (ExpAdd exp1 exp2) vars = do
  (ins1, m1) <- compileExpr exp1 vars
  (ins2, m2) <- compileExpr exp2 vars
  return $ if m1 > m2 then (ins1 ++ ins2 ++ ["iadd"], m2 + 1) else (ins2 ++ ins1 ++ ["iadd"], m1 + 1)
  -- return ((if s1 + m1 > m2 then ins1 ++ ins2 else ins2 ++ ins1) ++ ["iadd"], 1, max3 m1 m2 (s1 + s2))
  -- return $ if max1 > max2 then (ins1 ++ ins2 ++ ["iadd"], 1, 1) else (ins2 ++ ins1 ++ ["iadd"], 1, 1)
  -- return (ins2 ++ ins1 ++ ["iadd"])
-- compileExpr exp2 >>= \ins2 -> compileExpr exp1 >>= \ins1 -> return (ins2 ++ ins1)

compileExpr (ExpSub exp1 exp2) vars = do
  (ins1, m1) <- compileExpr exp1 vars
  (ins2, m2) <- compileExpr exp2 vars
  return $ if m1 > m2 then (ins1 ++ ins2 ++ ["isub"], m2 + 1) else (ins2 ++ ins1 ++ ["swap", "isub"], m1 + 1)
  -- return (ins1 ++ ins2 ++ ["isub"])

compileExpr (ExpMul exp1 exp2) vars = do
  (ins1, m1) <- compileExpr exp1 vars
  (ins2, m2) <- compileExpr exp2 vars
  return $ if m1 > m2 then (ins1 ++ ins2 ++ ["imul"], m2 + 1) else (ins2 ++ ins1 ++ ["imul"], m1 + 1)

compileExpr (ExpSub exp1 exp2) vars = do
  (ins1, m1) <- compileExpr exp1 vars
  (ins2, m2) <- compileExpr exp2 vars
  return $ if m1 > m2 then (ins1 ++ ins2 ++ ["idiv"], m2 + 1) else (ins2 ++ ins1 ++ ["swap", "idiv"], m1 + 1)

compileExpr (ExpLit n) _
  | n < 0 = throwError "Invalid number"
  | n <= 5 = return (["iconst_" ++ show n], 1)
  | n <= 127 = return (["bipush " ++ show n], 1)
  | n <= 32767 = return (["sipush " ++ show n], 1)
  | otherwise = return (["ldc " ++ show n], 1)

compileExpr (ExpVar (Ident name)) vars =
  case elemIndex name vars of
    Nothing -> throwError ("Reference to undefined variable: " ++ name)
    Just index -> return (["iload" ++ if index <= 3 then "_" else " " ++ show index], 1)
